const path = require('path')
const webpack = require('webpack')
const fs 	  = require('fs');
const chalk	  = require('chalk');
require('dotenv').config()

const buildConfig = require(path.join(__dirname, '../conf/build_config'))

if(!buildConfig) {
    console.error("Please create a build_config.js file at ./conf/ - See build_config.js.sample for details.")
    process.exit()
}

console.log(chalk.yellow('Build starting...'))

//Set the global path name for requiring modules.
global.__base = __dirname + '/'

//Reason I do this is to create an easy to configure, slow
// to build export process, so recompiling a new build in a rapid
// production environment is trivial.
var importArray = []

//Create an array of which widgets to include
buildConfig.widgets.forEach((widget) => {
    //Generate widget Class Name
    var widgetClass = widget.replace(/\W+(.)/g, (match, chr) => {return chr.toUpperCase()})
    widgetClass = 'boof' + (widgetClass.charAt(0).toUpperCase() + widgetClass.slice(1))
    var widgetDir = path.join(__dirname, '../src/' + widget + '/' + widget + '.js')

    //Check widget actually has a JS file before adding it
    try {
        //Attempt to access the file. If it fails, the loop will continue to the next iteration
        fs.accessSync(widgetDir)
        
        //Add it to the array to write the to the dummy import file
        importArray.push('import ' + widgetClass + ' from \'../src/' + widget + '/' + widget + '\'\n')
        //callArray.push(widgetClass + '()\n')

    } catch (e) {
        return
    }
})

//Add main file to end of dummy import file
importArray.push('import Main from \'../main\'\n\n')
importArray.push('Main()')

//Create empty 'tmp/build_helper.js' file, or clear the
// current existing file. Also creates the folder if it's
// not there. The tmp folder is cleaned later.
const tmp_dir = './tmp/'
if(!fs.existsSync(tmp_dir)) fs.mkdirSync(tmp_dir)

const build_log_path = tmp_dir + 'build_log.txt'
fs.closeSync(fs.openSync(build_log_path, 'w')); 

const build_helper_path = tmp_dir + 'build_helper.js'
fs.closeSync(fs.openSync(build_helper_path, 'w')); 

//Write configured widget classes to build helper file
let build_helper_file = fs.createWriteStream(build_helper_path, {flags: 'a'})
//Loop to add require calls
importArray.forEach((funcCall) => {
    build_helper_file.write(funcCall)
})

//Loop to write call to all component functions.
/*callArray.forEach((classPath) => {
    build_helper_file.write(classPath)
})
*/
build_helper_file.end()

//Config Generation Function
function webpackConfigGenerator(entry, outPath, outFilename, treeShake) {
    treeShake = (typeof treeShake === "undefined" ? false : treeShake)
    
    var generatedConfig = { //Global webpack config
        module: {
            rules: [{
                loader: 'babel-loader',
                exclude: /node_modules/,
                test: /\.js$/,
                query: {
                    presets: [['es2015', { "modules": false }]],  
                    plugins: ['transform-runtime'], 
                },
            }]
        },
    }

    //Webpack plugins for treeshaking
    if(treeShake) {
        generatedConfig.plugins = []
        generatedConfig.plugins.push(new webpack.optimize.UglifyJsPlugin({
            compressor: {warnings: false},
            output: {comments: false},
        }))

        generatedConfig.plugins.push(new webpack.LoaderOptionsPlugin({
            minimize: false,
            debug: false,
        }))
    }

    //Adding Entry & Out Points
    generatedConfig.entry = entry,
    generatedConfig.output = {
        path: outPath,
        filename: outFilename + (treeShake ? '.min' : '') + '.js'
    }

    return generatedConfig;
}

var config_array = []

//Main Distribution Build
    //TODO: Add this
    
//Custom Builds
    //Unminified
    config_array.push(webpackConfigGenerator(build_helper_path, path.resolve(__dirname, '../dist'), 'boof.custom', false))
    //Minified
    config_array.push(webpackConfigGenerator(build_helper_path, path.resolve(__dirname, '../dist'), 'boof.custom', true))

//Execute Webpack
webpack(config_array, (err, stats) => {
            
    var jsonStats = stats.toJson();

    if(stats.hasErrors()) {
        let build_log_file = fs.createWriteStream(build_log_path, {flags: 'a'})
        
        jsonStats.errors.forEach((err) => {
            build_log_file.write(err+'\n')
        }) //Write each line to log file
    
        build_log_file.end() //Close the stream once all errors output.
        console.log(chalk.red('Build Error! Log file: '+build_log_path))
        
        resolve()
    } else {
        console.log(chalk.green('Build Successful!'))

        //Clean up temporary files if they exist, so this can be run in-production
        fs.accessSync(build_helper_path, fs.F_OK, (err) => {
            if(!err) fs.unlinkSync(build_helper_path); 
        })
    }
})